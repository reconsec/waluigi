import json
import os
import subprocess
import netaddr
import socket
import luigi
import traceback
import os.path
import yaml

from luigi.util import inherits
from multiprocessing.pool import ThreadPool
from waluigi import scan_utils
from tqdm import tqdm
from waluigi import data_model


def subfinder_wrapper(scan_output_file_path, command, use_shell, my_env):

    ret_list = []
    # Call subfinder process
    error_flag = scan_utils.process_wrapper(command, use_shell, my_env)
    # print("[+] Process returned")
    # Parse the output
    obj_arr = scan_utils.parse_json_blob_file(scan_output_file_path)
    for domain_entry in obj_arr:
        domain_name = domain_entry['host']
        ip_str = domain_entry['ip']
        ret_list.append({'ip': ip_str, 'domain': domain_name})

    return ret_list


def get_subfinder_input(scheduled_scan_obj):

    scan_id = scheduled_scan_obj.scan_id

    # Init directory
    tool_name = scheduled_scan_obj.current_tool.name

    domain_name_set = set()
    scope_obj = scheduled_scan_obj.scan_data
    domain_map = scope_obj.domain_map
    for host_id in domain_map:
        domain_obj = domain_map[host_id]
        domain_name = domain_obj.name
        domain_name_set.add(domain_name)

    dir_path = scan_utils.init_tool_folder(tool_name, 'inputs', scan_id)
    dns_url_file = dir_path + os.path.sep + "dns_urls_" + scan_id

    with open(dns_url_file, 'w') as file_fd:
        for domain_name in domain_name_set:
            file_fd.write(domain_name + '\n')

    # Write the output
    scan_dict = {'input_path': dns_url_file}
    return scan_dict


def update_config_file(collection_tools, my_env):

    home_dir = os.path.expanduser('~')
    config_file_path = "%s/.config/subfinder/provider-config.yaml" % home_dir

    # If no file then run subfinder to generate the template
    if os.path.isfile(config_file_path) == False:
        subprocess.run(["subfinder", "-d", "localhost",
                       "-timeout", "1"], env=my_env)
        subprocess.run(["subfinder", "-h"], env=my_env)

    # Update provider config file
    with open(config_file_path, 'r') as file_fd:
        data = yaml.safe_load(file_fd)

    # print(data)
    data['chaos'] = []
    data['shodan'] = []
    data['securitytrails'] = []

    api_key_arr = ['chaos', 'shodan', 'securitytrails']
    if collection_tools:
        for collection_tool_inst in collection_tools:
            collection_tool = collection_tool_inst.collection_tool
            if collection_tool.name in api_key_arr and collection_tool.api_key:
                data[collection_tool.name] = [collection_tool.api_key]

    # Write to config file
    print(data)
    with open(config_file_path, 'w') as yaml_file:
        yaml_file.write(yaml.dump(data, default_flow_style=False))


def dns_wrapper(domain_set):

    ret_list = []
    try:

        thread_map = {}
        pool = ThreadPool(processes=20)

        for domain in domain_set:
            # Add argument without domain first
            thread_map[domain] = pool.apply_async(
                socket.gethostbyname, (domain, ))

        # Close the pool
        pool.close()

        # Loop through thread function calls and update progress
        # print(thread_map)
        for domain_str in thread_map:

            ip_domain_map = {}

            # Add domain
            ip_domain_map['domain'] = domain_str
            thread_obj = thread_map[domain_str]

            try:
                ip_str = thread_obj.get()
            except socket.gaierror as e:
                continue
            except Exception as e:
                print(e)
                continue

            # print("IP: %s" % ip_str)
            if ip_str and len(ip_str) > 0:

                # Ignore any autogenerated DNS names
                ip_arr = ip_str.split(".")
                ip_dot = ip_arr[2]+"."+ip_arr[3]
                ip_dash = ip_arr[2]+"-"+ip_arr[3]
                if ip_dot in domain_str or ip_dash in domain_str:
                    continue

                ip_domain_map['ip'] = ip_str

                # Add to the list
                ret_list.append(ip_domain_map)
                print("[*] Adding IP %s for hostname %s" %
                      (ip_str, domain_str))

    except subprocess.CalledProcessError as e:
        print("[*] called process error")
        pass
    except Exception as e:
        # Here we add some debugging help. If multiprocessing's
        # debugging is on, it will arrange to log the traceback
        print("[-] subfinder DNS thread exception.")
        print(traceback.format_exc())

    return ret_list


class SubfinderScan(luigi.Task):

    scan_input = luigi.Parameter()

    def output(self):

        scheduled_scan_obj = self.scan_input
        scan_id = scheduled_scan_obj.scan_id

        # Init directory
        tool_name = scheduled_scan_obj.current_tool.name
        dir_path = scan_utils.init_tool_folder(tool_name, 'outputs', scan_id)

        # path to input file
        dns_outputs_file = dir_path + os.path.sep + "subfinder_outputs_" + scan_id
        return luigi.LocalTarget(dns_outputs_file)

    def run(self):

        scheduled_scan_obj = self.scan_input
        dns_scan_obj = get_subfinder_input(scheduled_scan_obj)

        # Ensure output folder exists
        meta_file_path = self.output().path
        dir_path = os.path.dirname(meta_file_path)
        scan_output_file_path = dir_path + os.path.sep + "subfinder_results"

        # Write out meta data file
        output_fd = open(meta_file_path, 'w')
        ret_list = []

        subfinder_domain_list = dns_scan_obj['input_path']
        # api_keys = dns_scan_obj['api_keys']

        # Add env variables for HOME
        my_env = os.environ.copy()

        use_shell = False
        if os.name != 'nt':
            home_dir = os.path.expanduser('~')
            my_env["HOME"] = home_dir

        # Set the API keys
        update_config_file(
            list(scheduled_scan_obj.collection_tool_map.values()), my_env)

        # Add threads for large targets
        pool = ThreadPool(processes=10)
        thread_list = []

        # Add the domains from the wildcards
        with open(subfinder_domain_list, 'r') as file_fd:
            sub_lines = file_fd.readlines()

        # Add the lines
        domain_set = set()
        if len(sub_lines) > 0:
            for line in sub_lines:
                domain_str = line.strip()
                if len(domain_str) > 0:

                    domain_set.add(domain_str)

                    command = []
                    command_arr = [
                        "subfinder",
                        "-json",
                        "-d",
                        domain_str,
                        "-o",
                        scan_output_file_path,
                        "-active",
                        "-ip"
                    ]

                    command.extend(command_arr)

                    # Add optional arguments
                    # command.extend(option_arr)

                    thread_list.append(pool.apply_async(
                        subfinder_wrapper, (scan_output_file_path, command, use_shell, my_env)))

            # Close the pool
            pool.close()

            # Loop through thread function calls and update progress
            for thread_obj in tqdm(thread_list):
                temp_list = thread_obj.get()
                # print(temp_list)
                ret_list.extend(temp_list)

        # Reset the API keys
        update_config_file(None, my_env)

        # print(domain_set)
        if len(domain_set) > 0:
            ret_list.extend(dns_wrapper(domain_set))

        # print(ret_list)
        output_fd.write(json.dumps({'domain_list': ret_list}))
        output_fd.close()


@inherits(SubfinderScan)
class SubfinderImport(data_model.ImportToolXOutput):

    def requires(self):
        # Requires subfinderScan Task to be run prior
        return SubfinderScan(scan_input=self.scan_input)

    def run(self):

        subfinder_output_file = self.input().path
        with open(subfinder_output_file, 'r') as file_fd:
            data = file_fd.read()

        obj_map = {}
        if len(data) > 0:
            domain_map = json.loads(data)
            # print(domain_map)

            if 'domain_list' in domain_map:
                domain_list = domain_map['domain_list']

                ip_map = {}

                # Convert from domain to ip map to ip to domain map
                for domain_entry in domain_list:

                    # Get IP for domain
                    domain_str = domain_entry['domain']
                    ip_str = domain_entry['ip']

                    if ip_str in ip_map:
                        domain_list = ip_map[ip_str]
                    else:
                        domain_list = set()
                        ip_map[ip_str] = domain_list

                    domain_list.add(domain_str)

                for ip_addr in ip_map:

                    domain_set = ip_map[ip_addr]
                    domains = list(domain_set)

                    ip_object = netaddr.IPAddress(ip_addr)

                    host_obj = data_model.Host()
                    if ip_object.version == 4:
                        host_obj.ipv4_addr = str(ip_object)
                    elif ip_object.version == 6:
                        host_obj.ipv6_addr = str(ip_object)

                    # Add host
                    obj_map[host_obj.id] = host_obj

                    for domain in domains:

                        domain_obj = data_model.Domain(
                            parent_id=host_obj.id)
                        domain_obj.name = domain

                        # Add domain
                        obj_map[domain_obj.id] = domain_obj

        ret_arr = list(obj_map.values())

        # Import, Update, & Save
        scheduled_scan_obj = self.scan_input
        self.import_results(scheduled_scan_obj, ret_arr)
             