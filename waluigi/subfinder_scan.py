import json
import os
import netaddr
import socket
import luigi
import traceback
import os.path
import yaml
import logging

from luigi.util import inherits
from waluigi import scan_utils
from waluigi import data_model

logger = logging.getLogger(__name__)


class Subfinder(data_model.WaluigiTool):

    def __init__(self):
        self.name = 'subfinder'
        self.collector_type = data_model.CollectorType.ACTIVE.value
        self.scan_order = 1
        self.args = ""
        self.scan_func = Subfinder.subfinder_lookup
        self.import_func = Subfinder.subfinder_import

    @staticmethod
    def subfinder_lookup(scan_input):
        luigi_run_result = luigi.build([SubfinderScan(
            scan_input=scan_input)], local_scheduler=True, detailed_summary=True)
        if luigi_run_result and luigi_run_result.status != luigi.execution_summary.LuigiStatusCode.SUCCESS:
            return False
        return True

    @staticmethod
    def subfinder_import(scan_input):
        luigi_run_result = luigi.build([SubfinderImport(
            scan_input=scan_input)], local_scheduler=True, detailed_summary=True)
        if luigi_run_result and luigi_run_result.status != luigi.execution_summary.LuigiStatusCode.SUCCESS:
            return False
        return True


def subfinder_wrapper(scan_output_file_path, command, use_shell, my_env):

    ret_list = []
    # Call subfinder process
    error_flag = scan_utils.process_wrapper(command, use_shell, my_env)

    # Parse the output
    obj_arr = scan_utils.parse_json_blob_file(scan_output_file_path)
    for domain_entry in obj_arr:
        domain_name = domain_entry['host']
        ip_str = domain_entry['ip']
        ret_list.append({'ip': ip_str, 'domain': domain_name})

    return ret_list


def get_subfinder_input(scheduled_scan_obj):

    scan_id = scheduled_scan_obj.scan_id

    # Init directory
    tool_name = scheduled_scan_obj.current_tool.name

    domain_name_set = set()
    scope_obj = scheduled_scan_obj.scan_data
    domain_map = scope_obj.domain_map
    for host_id in domain_map:
        domain_obj = domain_map[host_id]
        domain_name = domain_obj.name
        domain_name_set.add(domain_name)

    dir_path = scan_utils.init_tool_folder(tool_name, 'inputs', scan_id)
    dns_url_file = dir_path + os.path.sep + "dns_urls_" + scan_id

    with open(dns_url_file, 'w') as file_fd:
        for domain_name in domain_name_set:
            file_fd.write(domain_name + '\n')

    # Write the output
    scan_dict = {'input_path': dns_url_file}
    return scan_dict


def update_config_file(collection_tools, my_env):

    home_dir = os.path.expanduser('~')
    config_file_path = "%s/.config/subfinder/provider-config.yaml" % home_dir

    # If no file then run subfinder to generate the template
    if os.path.isfile(config_file_path) == False:
        cmd_arr = ["subfinder", "-d", "localhost", "-timeout", "1"]
        future = scan_utils.executor.submit(
            scan_utils.process_wrapper, cmd_args=cmd_arr, my_env=my_env)
        future.result()

        cmd_arr = ["subfinder", "-h"]
        future = scan_utils.executor.submit(
            scan_utils.process_wrapper, cmd_args=cmd_arr, my_env=my_env)
        future.result()

    # Update provider config file
    with open(config_file_path, 'r') as file_fd:
        data = yaml.safe_load(file_fd)

    data['chaos'] = []
    data['shodan'] = []
    data['securitytrails'] = []

    api_key_arr = ['chaos', 'shodan', 'securitytrails']
    if collection_tools:
        for collection_tool_inst in collection_tools:
            collection_tool = collection_tool_inst.collection_tool
            if collection_tool.name in api_key_arr and collection_tool.api_key:
                data[collection_tool.name] = [collection_tool.api_key]

    # Write to config file
    with open(config_file_path, 'w') as yaml_file:
        yaml_file.write(yaml.dump(data, default_flow_style=False))


def dns_wrapper(domain_set):

    ret_list = []
    futures_map = {}

    for domain in domain_set:
        futures_map[domain] = scan_utils.executor.submit(
            socket.gethostbyname, domain)

    # Loop through thread function calls and update progress
    for domain_str in futures_map:

        ip_domain_map = {}

        # Add domain
        ip_domain_map['domain'] = domain_str
        thread_obj = futures_map[domain_str]

        # try:
        ip_str = thread_obj.result()
        if ip_str and len(ip_str) > 0:

            # Ignore any autogenerated DNS names
            ip_arr = ip_str.split(".")
            ip_dot = ip_arr[2]+"."+ip_arr[3]
            ip_dash = ip_arr[2]+"-"+ip_arr[3]
            if ip_dot in domain_str or ip_dash in domain_str:
                continue

            ip_domain_map['ip'] = ip_str

            # Add to the list
            ret_list.append(ip_domain_map)
            logger.debug("Adding IP %s for hostname %s" %
                         (ip_str, domain_str))

    return ret_list


class SubfinderScan(luigi.Task):

    scan_input = luigi.Parameter()

    def output(self):

        scheduled_scan_obj = self.scan_input
        scan_id = scheduled_scan_obj.scan_id

        # Init directory
        tool_name = scheduled_scan_obj.current_tool.name
        dir_path = scan_utils.init_tool_folder(tool_name, 'outputs', scan_id)

        # path to input file
        dns_outputs_file = dir_path + os.path.sep + "subfinder_outputs_" + scan_id
        return luigi.LocalTarget(dns_outputs_file)

    def run(self):

        scheduled_scan_obj = self.scan_input
        dns_scan_obj = get_subfinder_input(scheduled_scan_obj)

        tool_args = scheduled_scan_obj.current_tool.args
        if tool_args:
            tool_args = tool_args.split(" ")

        # Ensure output folder exists
        meta_file_path = self.output().path
        dir_path = os.path.dirname(meta_file_path)
        scan_output_file_path = dir_path + os.path.sep + "subfinder_results"

        # Write out meta data file
        output_fd = open(meta_file_path, 'w')
        ret_list = []

        subfinder_domain_list = dns_scan_obj['input_path']
        # api_keys = dns_scan_obj['api_keys']

        # Add env variables for HOME
        my_env = os.environ.copy()

        use_shell = False
        if os.name != 'nt':
            home_dir = os.path.expanduser('~')
            my_env["HOME"] = home_dir

        # Set the API keys
        update_config_file(
            list(scheduled_scan_obj.collection_tool_map.values()), my_env)

        # Add threads for large targets
        # pool = ThreadPool(processes=10)
        # thread_list = []

        futures = []

        # Add the domains from the wildcards
        with open(subfinder_domain_list, 'r') as file_fd:
            sub_lines = file_fd.readlines()

        # Add the lines
        domain_set = set()
        if len(sub_lines) > 0:
            for line in sub_lines:
                domain_str = line.strip()
                if len(domain_str) > 0:

                    domain_set.add(domain_str)

                    command = []
                    command_arr = [
                        "subfinder",
                        "-json",
                        "-d",
                        domain_str,
                        "-o",
                        scan_output_file_path,
                        "-active",
                        "-ip"
                    ]

                    command.extend(command_arr)

                    # Add script args
                    if tool_args and len(tool_args) > 0:
                        command.extend(tool_args)

                    futures.append(scan_utils.executor.submit(
                        subfinder_wrapper, scan_output_file_path, command, use_shell, my_env))

            for future in futures:
                temp_list = future.result()
                ret_list.extend(temp_list)

        # Reset the API keys
        update_config_file(None, my_env)

        if len(domain_set) > 0:
            ret_list.extend(dns_wrapper(domain_set))

        output_fd.write(json.dumps({'domain_list': ret_list}))
        output_fd.close()


@inherits(SubfinderScan)
class SubfinderImport(data_model.ImportToolXOutput):

    def requires(self):
        # Requires subfinderScan Task to be run prior
        return SubfinderScan(scan_input=self.scan_input)

    def run(self):

        subfinder_output_file = self.input().path
        with open(subfinder_output_file, 'r') as file_fd:
            data = file_fd.read()

        obj_map = {}
        if len(data) > 0:
            domain_map = json.loads(data)

            if 'domain_list' in domain_map:
                domain_list = domain_map['domain_list']

                ip_map = {}

                # Convert from domain to ip map to ip to domain map
                for domain_entry in domain_list:

                    # Get IP for domain
                    domain_str = domain_entry['domain']
                    ip_str = domain_entry['ip']

                    if ip_str in ip_map:
                        domain_list = ip_map[ip_str]
                    else:
                        domain_list = set()
                        ip_map[ip_str] = domain_list

                    domain_list.add(domain_str)

                for ip_addr in ip_map:

                    domain_set = ip_map[ip_addr]
                    domains = list(domain_set)

                    ip_object = netaddr.IPAddress(ip_addr)

                    host_obj = data_model.Host()
                    if ip_object.version == 4:
                        host_obj.ipv4_addr = str(ip_object)
                    elif ip_object.version == 6:
                        host_obj.ipv6_addr = str(ip_object)

                    # Add host
                    obj_map[host_obj.id] = host_obj

                    for domain in domains:

                        domain_obj = data_model.Domain(
                            parent_id=host_obj.id)
                        domain_obj.name = domain

                        # Add domain
                        obj_map[domain_obj.id] = domain_obj

        ret_arr = list(obj_map.values())

        # Import, Update, & Save
        scheduled_scan_obj = self.scan_input
        self.import_results(scheduled_scan_obj, ret_arr)
